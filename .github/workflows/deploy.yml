name: Deploy to AWS

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]
  workflow_dispatch:

env:
  AWS_REGION: us-east-1
  EB_APPLICATION_NAME: ecommerce-demo
  EB_ENVIRONMENT_NAME: ecommerce-demo-env
  S3_BUCKET_NAME: ecommerce-demo-frontend

jobs:
  test:
    name: Test Application
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
        
    - name: Install dependencies
      run: npm ci
      
    - name: Run tests
      run: npm test
      
    - name: Run security audit
      run: npm audit --audit-level moderate
      
    - name: Build application
      run: npm run build

  deploy:
    name: Deploy Full Application to Elastic Beanstalk
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
        
    - name: Install dependencies
      run: npm ci
      
    - name: Build frontend
      run: npm run build
      
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: Create deployment package
      run: |
        mkdir -p deploy-package
        # Copy backend files
        cp server/index.js deploy-package/
        cp package.json deploy-package/
        cp package-lock.json deploy-package/
        # Copy built frontend files
        cp -r dist deploy-package/
        # Create zip package
        cd deploy-package
        zip -r ../app.zip .
        
    - name: Create S3 bucket for deployment artifacts
      run: |
        aws s3 mb s3://${{ env.S3_BUCKET_NAME }} || echo "Bucket already exists"
        
    - name: Upload deployment package to S3
      run: |
        aws s3 cp app.zip s3://${{ env.S3_BUCKET_NAME }}/app-${{ github.sha }}.zip
        
    - name: Create Elastic Beanstalk application
      run: |
        aws elasticbeanstalk describe-applications --application-names ${{ env.EB_APPLICATION_NAME }} || \
        aws elasticbeanstalk create-application \
          --application-name ${{ env.EB_APPLICATION_NAME }} \
          --description "E-commerce demo application"
          
    - name: Create application version
      run: |
        aws elasticbeanstalk create-application-version \
          --application-name ${{ env.EB_APPLICATION_NAME }} \
          --version-label ${{ github.sha }} \
          --source-bundle S3Bucket=${{ env.S3_BUCKET_NAME }},S3Key=app-${{ github.sha }}.zip \
          --description "Deployment from GitHub Actions"
        
    - name: Create or update Elastic Beanstalk environment
      run: |
        # Check if environment exists
        if aws elasticbeanstalk describe-environments --environment-names ${{ env.EB_ENVIRONMENT_NAME }} --query 'Environments[0].Status' --output text | grep -q "Ready\|Updating"; then
          # Update existing environment
          aws elasticbeanstalk update-environment \
            --environment-name ${{ env.EB_ENVIRONMENT_NAME }} \
            --version-label ${{ github.sha }}
        else
          # Create new environment
          aws elasticbeanstalk create-environment \
            --application-name ${{ env.EB_APPLICATION_NAME }} \
            --environment-name ${{ env.EB_ENVIRONMENT_NAME }} \
            --version-label ${{ github.sha }} \
            --solution-stack-name "64bit Amazon Linux 2 v5.8.0 running Node.js 18" \
            --option-settings \
              Namespace=aws:autoscaling:launchconfiguration,OptionName=IamInstanceProfile,Value=aws-elasticbeanstalk-ec2-role \
              Namespace=aws:elasticbeanstalk:environment,OptionName=EnvironmentType,Value=SingleInstance \
              Namespace=aws:elasticbeanstalk:environment,OptionName=LoadBalancerType,Value=application
        fi
        
    - name: Wait for deployment to complete
      run: |
        aws elasticbeanstalk wait environment-updated --environment-names ${{ env.EB_ENVIRONMENT_NAME }}
        
    - name: Get application URL
      id: get-url
      run: |
        URL=$(aws elasticbeanstalk describe-environments \
          --environment-names ${{ env.EB_ENVIRONMENT_NAME }} \
          --query 'Environments[0].CNAME' \
          --output text)
        echo "app_url=http://$URL" >> $GITHUB_OUTPUT
        echo "Application deployed to: http://$URL"

  setup-infrastructure:
    name: Setup AWS Infrastructure
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch'
    
    steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: Create IAM role for Elastic Beanstalk
      run: |
        # Create trust policy
        cat > trust-policy.json << EOF
        {
          "Version": "2012-10-17",
          "Statement": [
            {
              "Effect": "Allow",
              "Principal": {
                "Service": "ec2.amazonaws.com"
              },
              "Action": "sts:AssumeRole"
            }
          ]
        }
        EOF
        
        # Create role if it doesn't exist
        aws iam create-role \
          --role-name aws-elasticbeanstalk-ec2-role \
          --assume-role-policy-document file://trust-policy.json || echo "Role already exists"
          
        # Attach policy
        aws iam attach-role-policy \
          --role-name aws-elasticbeanstalk-ec2-role \
          --policy-arn arn:aws:iam::aws:policy/AWSElasticBeanstalkWebTier || echo "Policy already attached"
          
        # Create instance profile
        aws iam create-instance-profile \
          --instance-profile-name aws-elasticbeanstalk-ec2-role || echo "Instance profile already exists"
          
        # Add role to instance profile
        aws iam add-role-to-instance-profile \
          --instance-profile-name aws-elasticbeanstalk-ec2-role \
          --role-name aws-elasticbeanstalk-ec2-role || echo "Role already in instance profile"
          
    - name: Create security group
      run: |
        # Get VPC ID
        VPC_ID=$(aws ec2 describe-vpcs --filters "Name=is-default,Values=true" --query 'Vpcs[0].VpcId' --output text)
        
        # Create security group
        SG_ID=$(aws ec2 create-security-group \
          --group-name ecommerce-demo-sg \
          --description "Security group for ecommerce demo application" \
          --vpc-id $VPC_ID \
          --query 'GroupId' \
          --output text 2>/dev/null || \
          aws ec2 describe-security-groups \
            --filters "Name=group-name,Values=ecommerce-demo-sg" \
            --query 'SecurityGroups[0].GroupId' \
            --output text)
            
        # Add inbound rules
        aws ec2 authorize-security-group-ingress \
          --group-id $SG_ID \
          --protocol tcp \
          --port 80 \
          --cidr 0.0.0.0/0 || echo "Rule already exists"
          
        aws ec2 authorize-security-group-ingress \
          --group-id $SG_ID \
          --protocol tcp \
          --port 443 \
          --cidr 0.0.0.0/0 || echo "Rule already exists"
          
        aws ec2 authorize-security-group-ingress \
          --group-id $SG_ID \
          --protocol tcp \
          --port 22 \
          --cidr 0.0.0.0/0 || echo "Rule already exists"
          
        echo "Security group created: $SG_ID"

  notify:
    name: Notify Deployment Status
    needs: [deploy]
    runs-on: ubuntu-latest
    if: always() && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')
    
    steps:
    - name: Notify Success
      if: needs.deploy.result == 'success'
      run: |
        echo "✅ Deployment successful!"
        echo "Application URL: ${{ needs.deploy.outputs.app_url }}"
        echo "API Health: ${{ needs.deploy.outputs.app_url }}/api/health"
        
    - name: Notify Failure
      if: needs.deploy.result == 'failure'
      run: |
        echo "❌ Deployment failed!"
        echo "Deploy status: ${{ needs.deploy.result }}"
